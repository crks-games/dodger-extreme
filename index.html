<!DOCTYPE html>
<html lang="en">
<head>
        <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z0545N293J"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-Z0545N293J');
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8987947512818621"
     crossorigin="anonymous"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dodger - EXTREME</title>
    <style>
        body {
            background-color: #111;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            border: 4px solid white;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            transition: border-color 0.5s, width 0.5s, height 0.5s;
            width: 600px;
            height: 400px;
        }

        canvas {
            display: block;
            background-color: black;
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-weight: bold;
            font-size: 18px;
            z-index: 5;
        }

        #mode-alert {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
            z-index: 5;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 10;
        }

        h1 { margin: 0 0 20px 0; font-size: 40px; color: red; }
        button {
            background: transparent;
            border: 2px solid yellow;
            color: yellow;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
        }
        button:hover { background: yellow; color: black; }
        
        .hp-bar { color: #ffeb3b; }
        .score-display { color: #fff; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="ui-layer">
            <span class="hp-bar">HP: <span id="hp-val">30/30</span></span>
            <span class="score-display">SCORE: <span id="score-val">0</span></span>
        </div>
        <div id="mode-alert">MODE CHANGE!</div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        
        <div id="game-over">
            <h1>GAME OVER</h1>
            <p>Score: <span id="final-score">0</span></p>
            <button onclick="resetGame()">Try Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        const hpEl = document.getElementById('hp-val');
        const scoreEl = document.getElementById('score-val');
        const finalScoreEl = document.getElementById('final-score');
        const gameOverScreen = document.getElementById('game-over');
        const modeAlert = document.getElementById('mode-alert');

        let animationId;
        let frame = 0;
        let score = 0;
        let isGameOver = false;

        // Arena boundaries (for Tiny mode)
        let arena = { x: 0, y: 0, w: 600, h: 400 };

        const player = {
            x: 300, y: 200,
            size: 16,
            speed: 5,
            color: '#ff0000',
            hp: 30, maxHp: 30,
            invincible: false, invincibleTimer: 0,
            vx: 0, vy: 0, // Velocity
            gravity: 0.6, jumpPower: -10,
            grounded: false
        };

        let currentMode = 'normal'; 
        let modeTimer = 0;
        let globalTimeScale = 1.0;

        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        let bullets = [];

        window.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });

        function resetGame() {
            player.hp = player.maxHp;
            player.invincible = false;
            bullets = [];
            score = 0;
            frame = 0;
            isGameOver = false;
            setMode('normal');
            gameOverScreen.style.display = 'none';
            hpEl.innerText = `${player.hp}/${player.maxHp}`;
            animate();
        }

        // --- MODE MANAGEMENT ---
        function setMode(mode) {
            currentMode = mode;
            modeTimer = 400; // Duration of hazard
            globalTimeScale = 1.0;
            
            // Reset Arena
            arena = { x: 0, y: 0, w: 600, h: 400 };
            container.style.width = '600px';
            container.style.height = '400px';
            canvas.width = 600;
            canvas.height = 400;

            let color = 'white';
            let text = "";

            switch(mode) {
                case 'normal': text = ""; color = 'white'; break;
                case 'gravity': text = "BLUE MODE (JUMP)"; color = '#0088ff'; player.vy = 0; break;
                case 'heavy': text = "PURPLE MODE (SLOW)"; color = '#9933ff'; break;
                case 'inverted': text = "ORANGE MODE (INVERTED)"; color = '#ffaa00'; break;
                case 'windy': text = "GREEN MODE (WIND)"; color = '#00ff00'; break;
                case 'icy': text = "CYAN MODE (SLIPPERY)"; color = '#00ffff'; break;
                case 'darkness': text = "DARKNESS"; color = '#333'; break;
                case 'tiny': 
                    text = "TINY ARENA"; 
                    color = '#888'; 
                    arena = { x: 150, y: 100, w: 300, h: 200 };
                    break;
                case 'blink': text = "BLINKING"; color = '#ffffff'; break;
                case 'turbo': text = "TURBO SPEED"; color = '#ff0000'; globalTimeScale = 1.5; break;
            }

            player.color = (mode === 'normal') ? '#ff0000' : color;
            container.style.borderColor = color;
            if(mode !== 'normal') {
                modeAlert.innerText = text;
                modeAlert.style.color = color;
                modeAlert.style.opacity = '1';
                setTimeout(() => modeAlert.style.opacity = '0', 2000);
            }
        }

        function manageModes() {
            if (currentMode !== 'normal') {
                modeTimer--;
                if (modeTimer <= 0) setMode('normal');
            } else {
                if (frame % 500 === 0 && frame > 100) {
                    const modes = ['gravity', 'heavy', 'inverted', 'windy', 'icy', 'darkness', 'tiny', 'blink', 'turbo'];
                    setMode(modes[Math.floor(Math.random() * modes.length)]);
                }
            }
        }

        // --- PHYSICS & CONTROLS ---
        function updatePlayer() {
            let spd = player.speed * globalTimeScale;
            if (currentMode === 'heavy') spd /= 2;
            
            let dx = 0; 
            let dy = 0;

            // Input Handling
            let up = keys.ArrowUp;
            let down = keys.ArrowDown;
            let left = keys.ArrowLeft;
            let right = keys.ArrowRight;

            if (currentMode === 'inverted') {
                up = keys.ArrowDown; down = keys.ArrowUp;
                left = keys.ArrowRight; right = keys.ArrowLeft;
            }

            // X Movement
            if (left) dx = -spd;
            if (right) dx = spd;

            // Y Movement (Normal)
            if (currentMode !== 'gravity') {
                if (up) dy = -spd;
                if (down) dy = spd;
            }

            // Physics Applications
            if (currentMode === 'icy') {
                // Apply force to velocity instead of direct position
                if (left) player.vx -= 0.5;
                if (right) player.vx += 0.5;
                if (up && currentMode !== 'gravity') player.vy -= 0.5;
                if (down && currentMode !== 'gravity') player.vy += 0.5;
                
                // Friction
                player.vx *= 0.92;
                player.vy *= 0.92;
                
                player.x += player.vx * globalTimeScale;
                player.y += player.vy * globalTimeScale;
            } 
            else if (currentMode === 'gravity') {
                // Horizontal is direct
                player.x += dx;
                
                // Vertical is physics
                player.vy += player.gravity * globalTimeScale;
                player.y += player.vy * globalTimeScale;

                // Floor collision
                if (player.y + player.size > arena.y + arena.h) {
                    player.y = arena.y + arena.h - player.size;
                    player.vy = 0;
                    player.grounded = true;
                } else {
                    player.grounded = false;
                }

                if (up && player.grounded) {
                    player.vy = player.jumpPower;
                }
            } 
            else {
                // Standard Movement
                player.x += dx;
                player.y += dy;
            }

            // Wind Effect
            if (currentMode === 'windy') {
                player.x += 1.5 * globalTimeScale;
            }

            // Boundary Checks (Dynamic based on Arena size)
            if (player.x < arena.x) player.x = arena.x;
            if (player.x + player.size > arena.x + arena.w) player.x = arena.x + arena.w - player.size;
            if (currentMode !== 'gravity') {
                if (player.y < arena.y) player.y = arena.y;
                if (player.y + player.size > arena.y + arena.h) player.y = arena.y + arena.h - player.size;
            }

            // Invincibility
            if (player.invincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) player.invincible = false;
            }
        }

        // --- BULLET SYSTEM ---
        function spawnBullet() {
            // Difficulty scaling
            let rate = Math.max(15, 50 - Math.floor(score / 300));
            if (currentMode === 'turbo') rate = Math.max(10, rate / 1.5);

            if (frame % rate === 0) {
                const r = Math.random();
                
                // 1. Standard (White)
                if (r < 0.25) {
                    bullets.push({ type: 'standard', x: Math.random() * arena.w + arena.x, y: arena.y - 20, w: 6, h: 6, vx: 0, vy: 3 + Math.random()*2, color: 'white' });
                }
                // 2. Side (Yellow)
                else if (r < 0.40) {
                    let fromLeft = Math.random() < 0.5;
                    bullets.push({ type: 'side', x: fromLeft ? arena.x - 20 : arena.x + arena.w + 20, y: Math.random() * arena.h + arena.y, w: 10, h: 6, vx: fromLeft ? 4+Math.random()*3 : -(4+Math.random()*3), vy: 0, color: '#ffff00' });
                }
                // 3. Homer (Purple)
                else if (r < 0.50) {
                    bullets.push({ type: 'homer', x: Math.random() * arena.w + arena.x, y: arena.y - 20, w: 8, h: 8, vx: 0, vy: 2, color: '#a020f0' });
                }
                // 4. Bouncer (Green)
                else if (r < 0.60) {
                     bullets.push({ type: 'bouncer', x: Math.random() * arena.w + arena.x, y: arena.y, w: 10, h: 10, vx: (Math.random()-0.5)*6, vy: 3, color: '#00ff00' });
                }
                // 5. Splitter (Pink)
                else if (r < 0.65) {
                    bullets.push({ type: 'splitter', x: Math.random() * arena.w + arena.x, y: arena.y - 20, w: 12, h: 12, vx: 0, vy: 3, split: false, color: '#ff69b4' });
                }
                // 6. Mine (Red pulse)
                else if (r < 0.70) {
                    bullets.push({ type: 'mine', x: Math.random() * arena.w + arena.x, y: arena.y - 20, w: 14, h: 14, vx: 0, vy: 4, state: 'fall', timer: 60, color: '#ff4444' });
                }
                // 7. Sine Wave (Cyan)
                else if (r < 0.75) {
                    bullets.push({ type: 'sine', startX: Math.random() * arena.w + arena.x, x: 0, y: arena.y - 20, w: 8, h: 8, vx: 0, vy: 3, t: 0, color: '#00ffff' });
                }
                // 8. Boomerang (Orange)
                else if (r < 0.80) {
                    bullets.push({ type: 'boomerang', x: player.x, y: arena.y - 20, w: 8, h: 14, vx: 0, vy: 6, state: 'down', color: '#ffaa00' });
                }
                // 9. Orbiter (White core, blue orbit)
                else if (r < 0.85) {
                    bullets.push({ type: 'orbiter', x: Math.random() * arena.w + arena.x, y: arena.y - 20, w: 12, h: 12, vx: 0, vy: 2, angle: 0, color: 'white' });
                }
            }

            // Specialized Spawns (Less frequent)
            // 10. Laser (Red Beam)
            if (frame % 200 === 0 && Math.random() > 0.4) {
                bullets.push({ type: 'laser', x: player.x + 8, y: 0, w: 2, h: canvas.height, state: 'warn', timer: 60, color: 'red' });
            }
            // 11. Spear (Upward Spike)
            if (frame % 180 === 0 && Math.random() > 0.5) {
                bullets.push({ type: 'spear', x: player.x, y: arena.y + arena.h, w: 10, h: 0, maxH: 100, state: 'rise', color: '#aaa' });
            }
            // 12. Grid (Horizontal Wall)
            if (frame % 350 === 0) {
                let gap = Math.floor(Math.random() * 10);
                for(let i=0; i<10; i++) {
                    if (i === gap || i === gap+1) continue;
                    bullets.push({ type: 'standard', x: arena.x + (i * (arena.w/10)) + 10, y: arena.y - 50, w: 10, h: 10, vx: 0, vy: 2.5, color: '#555' });
                }
            }
            // 13. Ring (Explosion)
            if (frame % 400 === 0) {
                let cx = arena.x + arena.w/2;
                let cy = arena.y + arena.h/3;
                for (let i=0; i<8; i++) {
                    let angle = (Math.PI*2 / 8) * i;
                    bullets.push({ type: 'standard', x: cx, y: cy, w: 8, h: 8, vx: Math.cos(angle)*3, vy: Math.sin(angle)*3, color: 'cyan' });
                }
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                let ts = globalTimeScale;

                // --- LOGIC ---
                if (b.type === 'standard' || b.type === 'side') {
                    b.x += b.vx * ts;
                    b.y += b.vy * ts;
                }
                else if (b.type === 'homer') {
                    b.y += b.vy * ts;
                    if(b.x < player.x) b.x += 0.5 * ts;
                    if(b.x > player.x) b.x -= 0.5 * ts;
                }
                else if (b.type === 'bouncer') {
                    b.x += b.vx * ts;
                    b.y += b.vy * ts;
                    if (b.x <= arena.x || b.x + b.w >= arena.x + arena.w) b.vx *= -1;
                }
                else if (b.type === 'splitter') {
                    b.y += b.vy * ts;
                    if (!b.split && b.y > arena.y + arena.h / 2) {
                        b.split = true;
                        bullets.push({ type: 'standard', x: b.x, y: b.y, w: 8, h: 8, vx: -3, vy: 2, color: b.color });
                        bullets.push({ type: 'standard', x: b.x, y: b.y, w: 8, h: 8, vx: 3, vy: 2, color: b.color });
                        bullets.splice(i, 1);
                        continue;
                    }
                }
                else if (b.type === 'mine') {
                    if (b.state === 'fall') {
                        b.y += b.vy * ts;
                        if (b.y > arena.y + arena.h / 2) b.state = 'wait';
                    } else if (b.state === 'wait') {
                        b.timer -= 1 * ts;
                        b.color = (Math.floor(frame/5)%2===0) ? 'red' : 'white';
                        if (b.timer <= 0) {
                            // Explode
                            bullets.push({ type: 'standard', x: b.x, y: b.y, w: 8, h: 8, vx: -4, vy: -4, color: 'red' });
                            bullets.push({ type: 'standard', x: b.x, y: b.y, w: 8, h: 8, vx: 4, vy: -4, color: 'red' });
                            bullets.push({ type: 'standard', x: b.x, y: b.y, w: 8, h: 8, vx: -4, vy: 4, color: 'red' });
                            bullets.push({ type: 'standard', x: b.x, y: b.y, w: 8, h: 8, vx: 4, vy: 4, color: 'red' });
                            bullets.splice(i, 1);
                            continue;
                        }
                    }
                }
                else if (b.type === 'sine') {
                    b.t += 0.1 * ts;
                    b.y += b.vy * ts;
                    b.x = b.startX + Math.sin(b.t) * 50;
                }
                else if (b.type === 'laser') {
                    if (b.state === 'warn') {
                        b.w = 2;
                        b.timer -= 1 * ts;
                        if (b.timer <= 0) {
                             b.state = 'fire'; 
                             b.w = 20; // expand hitbox
                             b.timer = 20; // duration
                             b.x -= 9; // center correction
                        }
                    } else {
                        b.timer -= 1 * ts;
                        if (b.timer <= 0) {
                            bullets.splice(i, 1);
                            continue;
                        }
                    }
                }
                else if (b.type === 'spear') {
                    if (b.state === 'rise') {
                        b.h += 5 * ts;
                        b.y -= 5 * ts;
                        if (b.h >= b.maxH) b.state = 'retract';
                    } else {
                        b.h -= 2 * ts;
                        b.y += 2 * ts;
                        if (b.h <= 0) {
                            bullets.splice(i, 1);
                            continue;
                        }
                    }
                }
                else if (b.type === 'boomerang') {
                    if (b.state === 'down') {
                        b.y += b.vy * ts;
                        if (b.y > arena.y + arena.h - 50) b.state = 'up';
                    } else {
                        b.y -= b.vy * ts;
                    }
                }
                else if (b.type === 'orbiter') {
                    b.y += b.vy * ts;
                    b.angle += 0.1 * ts;
                    // Note: Collision handled for core, we need to manually draw/check the orbiter
                }

                // --- COLLISION ---
                // Simple AABB
                let hit = false;
                
                // Extra check for Orbiter satellite
                if (b.type === 'orbiter') {
                    let satX = b.x + Math.cos(b.angle)*30;
                    let satY = b.y + Math.sin(b.angle)*30;
                    if (player.x < satX + 10 && player.x + player.size > satX &&
                        player.y < satY + 10 && player.y + player.size > satY) hit = true;
                }

                if (
                    player.x < b.x + b.w &&
                    player.x + player.size > b.x &&
                    player.y < b.y + b.h &&
                    player.y + player.size > b.y
                ) {
                    hit = true;
                    // Laser only hits in 'fire' state
                    if (b.type === 'laser' && b.state === 'warn') hit = false;
                }

                if (hit && !player.invincible) {
                    player.hp -= 10;
                    hpEl.innerText = `${player.hp}/${player.maxHp}`;
                    player.invincible = true;
                    player.invincibleTimer = 60;
                    if (player.hp <= 0) endGame();
                }

                // Cleanup bounds
                if (b.type !== 'boomerang' && b.type !== 'spear' && b.type !== 'laser' && b.type !== 'mine') {
                    if (b.y > 600 || b.x < -100 || b.x > 700 || b.y < -100) bullets.splice(i, 1);
                }
            }
        }

        function endGame() {
            isGameOver = true;
            cancelAnimationFrame(animationId);
            finalScoreEl.innerText = score;
            gameOverScreen.style.display = 'block';
        }

        function draw() {
            // Draw Background (Clear)
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Tiny Arena Border (if active)
            if (currentMode === 'tiny') {
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.strokeRect(arena.x, arena.y, arena.w, arena.h);
            }

            // Draw Player
            if (!player.invincible || frame % 4 === 0) {
                if (currentMode !== 'blink' || frame % 10 < 5) {
                    ctx.fillStyle = player.color;
                    ctx.fillRect(player.x, player.y, player.size, player.size);
                }
            }

            // Draw Bullets
            bullets.forEach(b => {
                ctx.fillStyle = b.color;
                
                if (b.type === 'orbiter') {
                    // Core
                    ctx.beginPath(); ctx.arc(b.x + b.w/2, b.y + b.h/2, b.w/2, 0, Math.PI*2); ctx.fill();
                    // Satellite
                    let satX = b.x + Math.cos(b.angle)*30;
                    let satY = b.y + Math.sin(b.angle)*30;
                    ctx.fillStyle = '#0088ff';
                    ctx.beginPath(); ctx.arc(satX + 5, satY + 5, 5, 0, Math.PI*2); ctx.fill();
                }
                else if (b.type === 'laser') {
                    if (b.state === 'warn') ctx.globalAlpha = 0.5;
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                    ctx.globalAlpha = 1.0;
                }
                else if (b.type === 'spear') {
                    ctx.beginPath();
                    ctx.moveTo(b.x, b.y + b.h);
                    ctx.lineTo(b.x + b.w/2, b.y);
                    ctx.lineTo(b.x + b.w, b.y + b.h);
                    ctx.fill();
                }
                else {
                    // Generic shapes
                    if (b.w === b.h) { // Circle-ish
                        ctx.beginPath();
                        ctx.arc(b.x + b.w/2, b.y + b.h/2, b.w/2, 0, Math.PI*2);
                        ctx.fill();
                    } else {
                        ctx.fillRect(b.x, b.y, b.w, b.h);
                    }
                }
            });

            // Draw Darkness Overlay
            if (currentMode === 'darkness') {
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.arc(player.x + player.size/2, player.y + player.size/2, 100, 0, Math.PI * 2, true);
                ctx.fill();
            }
        }

        function animate() {
            if (isGameOver) return;
            
            frame++;
            score++;
            scoreEl.innerText = score;

            manageModes();
            updatePlayer();
            spawnBullet();
            updateBullets();
            draw();

            animationId = requestAnimationFrame(animate);
        }

        resetGame();
    </script>
</body>
</html>
